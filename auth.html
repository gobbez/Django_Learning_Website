<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autenticazione in Django</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Benvenuti nel Mondo di Django</h1>
        <nav>
            <a href="index.html">Home</a>
            <a href="introduzione.html">Introduzione</a>
            <a href="setup.html">Setup</a>
            <a href="primo-progetto.html">Primo Progetto</a>
            <a href="models.html">Models</a>
            <a href="views.html">Views</a>
            <a href="templates.html">Templates</a>
            <a href="forms.html">Forms</a>
            <a href="admin.html">Admin</a>
            <a href="auth.html">Autenticazione</a>
            <a href="middleware.html">Middleware</a>
        </nav>
    </header>
    <main>
        <section class="content">
            <h2>Sistema di Autenticazione Avanzato: Sicurezza e User Experience</h2>
            <p>L'autenticazione in Django va oltre semplice login/logout. È un framework completo per gestire utenti, permessi, gruppi e sessioni che permette di creare applicazioni multi-tenant sicure e scalabili.</p>

            <h3>Il Modello User e Estensioni</h3>
            <p>Django fornisce un modello User robusto che può essere esteso per requisiti specifici:</p>
            <div class="code-block">
                <pre>
from django.contrib.auth.models import AbstractUser
from django.db import models

class CustomUser(AbstractUser):
    """Modello utente esteso con campi aggiuntivi"""
    bio = models.TextField(blank=True, null=True)
    avatar = models.ImageField(upload_to='avatars/', blank=True, null=True)
    date_of_birth = models.DateField(blank=True, null=True)
    phone = models.CharField(max_length=15, blank=True)

    # Preferenze utente
    theme = models.CharField(
        max_length=10,
        choices=[('light', 'Chiaro'), ('dark', 'Scuro')],
        default='light'
    )
    notifications = models.BooleanField(default=True)

    def get_full_name(self):
        """Override per includere titolo"""
        return f"{self.get_title_display()} {super().get_full_name()}"

    def get_age(self):
        """Calcola età se disponibile"""
        if self.date_of_birth:
            from datetime import date
            today = date.today()
            return today.year - self.date_of_birth.year - (
                (today.month, today.day) < (self.date_of_birth.month, self.date_of_birth.day)
            )
        return None
                </pre>
            </div>

            <h3>User Profiles con One-to-One Relationships</h3>
            <p>Per estensioni più modulari senza modificare il modello User direttamente:</p>
            <div class="code-block">
                <pre>
class UserProfile(models.Model):
    """Profilo esteso collegato all'utente"""
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    website = models.URLField(blank=True)
    location = models.CharField(max_length=100, blank=True)
    skills = models.ManyToManyField('Skill', blank=True)

    def __str__(self):
        return f"Profilo di {self.user.username}"

# Segnale per creare automaticamente il profilo
from django.db.models.signals import post_save
from django.dispatch import receiver

@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def create_user_profile(sender, instance, created, **kwargs):
    if created:
        UserProfile.objects.create(user=instance)

@receiver(post_save, sender=settings.AUTH_USER_MODEL)
def save_user_profile(sender, instance, **kwargs):
    instance.userprofile.save()
                </pre>
            </div>

            <h3>Authentication Views Avanzate</h3>
            <p>Django offre views class-based potenti per l'autenticazione:</p>
            <div class="code-block">
                <pre>
from django.contrib.auth.views import LoginView, LogoutView, PasswordChangeView
from django.contrib.auth.mixins import LoginRequiredMixin
from django.urls import reverse_lazy

class CustomLoginView(LoginView):
    template_name = 'registration/login.html'
    redirect_authenticated_user = True

    def get_success_url(self):
        """Redirect basato sul tipo di utente"""
        if self.request.user.is_staff:
            return reverse_lazy('admin:index')
        return reverse_lazy('dashboard')

class CustomPasswordChangeView(LoginRequiredMixin, PasswordChangeView):
    template_name = 'registration/password_change.html'
    success_url = reverse_lazy('password_change_done')

    def form_valid(self, form):
        """Logga il cambio password per sicurezza"""
        import logging
        logger = logging.getLogger('security')
        logger.info(f"Password changed for user: {self.request.user.username}")
        return super().form_valid(form)
                </pre>
            </div>

            <h3>Decoratori e Mixins per Protezione</h3>
            <p>Protezione granulare delle views con permessi personalizzati:</p>
            <div class="code-block">
                <pre>
from django.contrib.auth.decorators import login_required, permission_required
from django.contrib.auth.mixins import PermissionRequiredMixin, UserPassesTestMixin
from django.http import HttpResponseForbidden

def can_edit_post(user, post):
    """Controllo personalizzato per editing"""
    return user.is_staff or user == post.author or user.has_perm('blog.can_edit_all_posts')

@login_required
@permission_required('blog.add_post', raise_exception=True)
def create_post(request):
    """Solo utenti autenticati con permesso possono creare post"""
    # logica della view...

class PostUpdateView(LoginRequiredMixin, UserPassesTestMixin):
    model = Post
    template_name = 'blog/post_edit.html'

    def test_func(self):
        """Test personalizzato per accesso alla view"""
        post = self.get_object()
        return can_edit_post(self.request.user, post)

    def handle_no_permission(self):
        """Gestione mancanza permessi"""
        if not self.request.user.is_authenticated:
            return super().handle_no_permission()
        return HttpResponseForbidden("Non hai i permessi per modificare questo post")
                </pre>
            </div>

            <h3>Sessioni e Token Authentication</h3>
            <p>Gestione avanzata delle sessioni per sicurezza e scalabilità:</p>
            <div class="code-block">
                <pre>
# settings.py
SESSION_ENGINE = 'django.contrib.sessions.backends.cached_db'
SESSION_COOKIE_AGE = 86400  # 24 ore
SESSION_SAVE_EVERY_REQUEST = True
SESSION_EXPIRE_AT_BROWSER_CLOSE = False

# Middleware personalizzato per sicurezza sessioni
class SecurityMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        # Controlla IP per prevenire hijacking
        if request.user.is_authenticated:
            current_ip = get_client_ip(request)
            stored_ip = request.session.get('ip_address')

            if stored_ip and current_ip != stored_ip:
                # IP cambiato, logout forzato
                from django.contrib.auth import logout
                logout(request)
                return redirect('login')

            request.session['ip_address'] = current_ip

        return self.get_response(request)

# API Authentication con Token
from rest_framework.authtoken.models import Token

def get_or_create_token(request):
    if request.method == 'POST':
        user = authenticate(username=request.POST['username'], password=request.POST['password'])
        if user:
            token, created = Token.objects.get_or_create(user=user)
            return JsonResponse({'token': token.key})
    return JsonResponse({'error': 'Credenziali non valide'}, status=400)
                </pre>
            </div>

            <h3>Social Authentication</h3>
            <p>Integrazione con provider esterni come Google, GitHub, Facebook:</p>
            <div class="code-block">
                <pre>
# Utilizzando django-allauth
# settings.py
INSTALLED_APPS = [
    'django.contrib.auth',
    'django.contrib.messages',
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    'allauth.socialaccount.providers.google',
    'allauth.socialaccount.providers.github',
]

SOCIALACCOUNT_PROVIDERS = {
    'google': {
        'SCOPE': ['profile', 'email'],
        'AUTH_PARAMS': {'access_type': 'online'}
    }
}

# urls.py
from allauth.socialaccount.urls import urlpatterns as socialaccount_urls

urlpatterns = [
    path('accounts/', include('allauth.urls')),
    # ... altre url
] + socialaccount_urls
                </pre>
            </div>

            <p>Il sistema di autenticazione di Django fornisce fondamenta solide per costruire applicazioni sicure, scalabili e user-centric che soddisfano i requisiti più complessi.</p>
            <a href="middleware.html" class="next-link">Scopri il Middleware</a>
        </section>
    </main>
    <footer>
        <p>&copy; 2025 Sito Educativo su Django</p>
    </footer>
</body>
</html>
